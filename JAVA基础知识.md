* [1.1 一切都是对象](#1.1)
* [2.1 操作符](#2.1)
* [3.1 控制执行流程](#3.1)
* [4.1 初始化和清理](#4.1)
* [5.1 访问权限控制](#5.1)
* [6.1 复用类](#6.1)
* [7.1 多态](#6.1)


##1.1一切都是对象

 - new将对象存储在堆里，对于基本类型不是new创建基本类型变量而是使用并非引用的创建自动变量，这个变量直接存储在堆栈中更加高效；
 
 - 若类的某个成员是基本类型，java会给定默认值；当为局部变量时则不会保证有默认值；
 
 - java传递对象实际传递的是引用；
 
 - 基本类型比较实用==或者！=，对象类型比较使用equals方法；


##3.1控制执行流程

- 不允许使用数字作为布尔值使用；

- 逗号操作符

    `for(int i=1,j=i+1;i<10;i++,j++){
			System.out.print("i="+i + " "+"j="+j);}`

##4.1初始化和清理

  - 方法重载：方法名相同，参数列表不同或者参数的顺序不同；
  - 默认构造器：默认构造器是没有形式参数；若类中未定义构造器，则会自动创建默认构造器，若定义构造器则不会默认创建；
  - this关键字：this关键字只能在方法内部使用，表示对“调用方法那个那个对象”引用；
  - 构造器调用构造器：只能调用一个构造器，不能调用两个或者两个以上；被调用构造器应置于起始处；
  - 构造器初始化顺序:先初始化new对象，再初始化构造器；

## 5.1 访问权限控制
 - 编译一个java文件同时会生成名称相同，后缀为.class文件；
 - java包的命名规则全部使用小写字母；

## 6.1 复用类
 - final关键字：
   1. final修饰基本数据类型值，并表示为不改变的编译类型常量；
   2. java允许空白final,所谓空白final是指在声明处为给定初始值，但在构造器中必须对final进行赋值，确保final在使用前必须初始化；
   3. final修饰参数列表，将无法在方法中更改参数引用所指向的对象；
   4. final修饰方法，明确禁止 该方法在子类中不被覆盖的情况下才将方法设置为final的；
   5. final修饰类，表示此类不能被继承；
## 6.1 多态

- 向上转型：某个对象的引用视为对基类类型引用；
- 动态绑定：通过后期绑定的方式，在运行过程中根据对象类型进行绑定实现。
- 多态：只要发消息给基类即可完成，由动态绑定既可判断操作的对象类型，进而调用具体对象的方法，具有可扩展性。
     - 只有普通的方法可以实现多态；
     - 域和静态方法在编译期进行解析，因此不能实现多态；

  ![](https://i.imgur.com/28YTWhE.png)


- 覆盖：非private方法可以覆盖，如图中f2(),private方法自动认为是final对导出类是屏蔽的，如图中f1()，不能实现覆盖；

  ![](https://i.imgur.com/4iEwVsX.png)

## 7.1 接口

**抽象类**

1. 抽象类表示所有导出类的共同部分，公共部分只是约束继承类实现的方法；
2. 包含抽象方法的类一定是抽象类；

**接口**

1. 接口提供一个完全抽象类，他不提供任何具体的实现；
2. 接口也可以向上转型；
3. 可以继承任意多个接口，并可以向上转型为每个接口
4. 通过接口之间的继承，扩展接口方法；
5. 放入接口中的任何域都自动是static	且final的，因此可以被用来当enum使用；

**适配接口**

 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
![](https://i.imgur.com/POasAaE.png)

我们知道显示器(Client)是用来显示图形的，它是不能显示数据，它只能够接受来自图形发送设备Target的信号。可是我们手头上只有CPU(Adaptee)这个产生各种描述图形的数据的数据发送器。我们需要将这些数据让显示器进行显示，可是这两个部件却是不兼容的。于是我们需要一个中间设备，它能够将CPU“适配”于显示器，这便是我们的显卡——图形适配器(Adapter)。

**嵌套接口**



**工厂模式**

使用接口实现工厂模式，serviceFactory工厂接口，implementationFactory1和implementationFactory2 是两种类型的工厂。service 是产品接口，service1和service2是两种产品。不同的工厂生产不同的产品
![](https://i.imgur.com/DnrKpR2.png)


## 8.1 内部类

## 8.1 持有对象



   
   