# 二、对象及变量的并发访问 #

> '非线程安全'是多个线程对同一个对象实例变量进行并发访问时发生。

* [2.1synchronized同步方法](#2.1)
 * [2.1.1 方法内变量为线程安全](#2.1.1)
 * [2.1.2 实例变量非线程安全](#2.1.2)
 * [2.1.3 多个对象多个锁](#2.1.3)
 * [2.1.4 synchronized方法和锁对象](#2.1.4)
 * [2.1.5 synchronized锁重入](#2.1.5)
 * [2.1.6 出现异常自动释放锁](#2.1.6)
 * [2.1.7 锁同步不具有继承性](#2.1.7)
* [2.2synchronized同步代码块](#2.2)
* [2.3 Valatile关键字](#2.3)
 * [2.3.1 volatile关键字作用](#2.3.1)
 * [2.3.2 volatile不支持原子性](#2.3.2)
 * [2.3.3 变量在内存中的工作过程](#2.3.3)
 * [2.3.4 使用原子类](#2.3.4)
 


## 2.1.1方法内变量为线程安全
方法中变量不存在线程不安全问题。

##2.1.2 实例变量非线程安全
量个变量同时访问一个没有同步的方法，若两个对象同时操作业务对象中的实例变量，则有可能出现非线程安全问题。

##2.2 synchronized同步代码块
* synchronized同步方法的主要弊端是效率比较低，synchronized同步代码块可以提高运行效率。
* 不在synchronized同步代码块是异步执行，在synchronized同步代码块中是同步执行。


##2.3 Valatile关键字


###2.3.1 volatile关键字作用
关键字volatile的作用是强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取的变量值。

**- 案例：**

    package printString;

    public class PrintString extends Thread{
	
    private Boolean isContinuePrint=true;
	
	private void printStringMethod(){
		System.out.println("线程开始");
		while(isContinuePrint){
			
		}
		System.out.println("线程结束");
	}
	
	@Override
	public void run() {
		// TODO Auto-generated method stub
		printStringMethod();
	}
	public void setIsContinuePrint(Boolean isContinuePrint) {
		this.isContinuePrint = isContinuePrint;
	}
    }

----------


    package printString;

    public class PrintString extends Thread{
	
    Valatile private Boolean isContinuePrint=true;
	
	private void printStringMethod(){
		System.out.println("线程开始");
		while(isContinuePrint){
			
		}
		System.out.println("线程结束");
	}
	
	@Override
	public void run() {
		// TODO Auto-generated method stub
		printStringMethod();
	}
	public void setIsContinuePrint(Boolean isContinuePrint) {
		this.isContinuePrint = isContinuePrint;
	}
    }

----------

    package printString;

    public class TestMain {
	public static void main(String[] args) throws InterruptedException {
		// TODO Auto-generated method stub
		PrintString printString=new PrintString();
		printString.start();
		System.out.println("停止线程");
		Thread.sleep(1000);
		printString.setIsContinuePrint(false);
	}
    }

**运行结果：**

![](https://i.imgur.com/4jXHkjW.png)

**问题原因：**
私有堆栈中值和公共堆栈中的值不统一造成，解决问题使用Valatile关键字修饰isContinuePrint使取值时强制从公共堆栈中取值。

###2.3.2 volatile不支持原子性
volatile关键字增加了实例变量在多个线程之间的可见性，但是volatile关键字不支持变量的原子性。

###2.3.3 变量在内存中的工作过程
* read and load阶段：从主存复制变量到当前工作内存空间;
* use and assign阶段：执行代码，改变共享变量值；
* store and write阶段：工作空间内存刷新到主存对应的变量值；

###2.3.4 使用原子类
由于变量的工作过程是非线性安全的，因此可以使用原子类变量AtomincInteger实现变量的原子性。原子操作是不可分割的整体，没有其他线程能够中断或检查正在原子操作的变量。

非原子性

    package printString;

    public class TestAtomic extends Thread{
	
    public static int count;
	
	@Override
	public void run() {
		// TODO Auto-generated method stub
		for(int i=0;i<10000;i++){
			count++;
		}
		System.out.println("当前count值"+getCount());
	}

	public int getCount() {
		return count;
	}

	public void setCount(int count) {
		this.count = count;
	}
    }

----------
原子性

    package printString;

    import java.util.concurrent.atomic.AtomicInteger;

    public class TestAtomic extends Thread{
	
    public static AtomicInteger count=new AtomicInteger(0);
	
	@Override
	public void run() {
		// TODO Auto-generated method stub
		synchronized (TestAtomic.class) {
			for(int i=0;i<10;i++){
				count.incrementAndGet();
				
			}
			System.out.println("当前count值"+count.get());
		}
	}
    }

# 三、线程间通信 #
* [3.1等待通知机制](#3.1)


###3.1 等待通知机制
方法wait()的作用是使当前正在执行线程进行等待，wait()是object类方法，该方法将当前正在执行的线程置入"预执行队列"中，并且在wait()所在的代码出停止执行，直到被通知或者中断；
方法notify()的作用是用来通知那些等待该对象的对象锁，如果有多个线程，随机挑选一个成为wait()状态的线程。


1.  在调用wait()前，线程必须获取对象的对象级别锁，因此wait()方法只能在同步代码块或者同步方法中调用；
2.   在调用notify()前，线程必须获取对象的对象级别锁，因此notify()方法只能在同步代码块或者同步方法中调用；
3.   执行notify()方法后，当前线程不会立即释放该对象锁；
4.   执行wait()方法后，当前线程会立即释放该对象锁；
5.   wait()使线程停止运行，notify()使停止的线程继续运行；






