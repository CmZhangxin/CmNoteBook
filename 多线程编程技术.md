# 二、对象及变量的并发访问 #

> '非线程安全'是多个线程对同一个对象实例变量进行并发访问时发生。

* [2.1synchronized同步方法](#2.1)
 * [2.1.1 方法内变量为线程安全](#2.1.1)
 * [2.1.2 实例变量非线程安全](#2.1.2)
 * [2.1.3 多个对象多个锁](#2.1.3)
 * [2.1.4 synchronized方法和锁对象](#2.1.4)
 * [2.1.5 synchronized锁重入](#2.1.5)
 * [2.1.6 出现异常自动释放锁](#2.1.6)
 * [2.1.7 锁同步不具有继承性](#2.1.7)
* [2.2synchronized同步代码块](#2.2)
* [2.3 Valatile关键字](#2.3)
 * [2.3.1 volatile关键字作用](#2.3.1)
 * [2.3.2 volatile不支持原子性](#2.3.2)
 * [2.3.3 变量在内存中的工作过程](#2.3.3)
 


## 2.1.1方法内变量为线程安全
方法中变量不存在线程不安全问题。

##2.1.2 实例变量非线程安全
量个变量同时访问一个没有同步的方法，若两个对象同时操作业务对象中的实例变量，则有可能出现非线程安全问题。

##2.2 synchronized同步代码块
* synchronized同步方法的主要弊端是效率比较低，synchronized同步代码块可以提高运行效率。
* 不在synchronized同步代码块是异步执行，在synchronized同步代码块中是同步执行。


##2.3 Valatile关键字


###2.3.1 volatile关键字作用
关键字volatile的作用是强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取的变量值。

**- 案例：**

    package printString;

    public class PrintString extends Thread{
	
    private Boolean isContinuePrint=true;
	
	private void printStringMethod(){
		System.out.println("线程开始");
		while(isContinuePrint){
			
		}
		System.out.println("线程结束");
	}
	
	@Override
	public void run() {
		// TODO Auto-generated method stub
		printStringMethod();
	}
	public void setIsContinuePrint(Boolean isContinuePrint) {
		this.isContinuePrint = isContinuePrint;
	}
    }

----------


    package printString;

    public class PrintString extends Thread{
	
    Valatile private Boolean isContinuePrint=true;
	
	private void printStringMethod(){
		System.out.println("线程开始");
		while(isContinuePrint){
			
		}
		System.out.println("线程结束");
	}
	
	@Override
	public void run() {
		// TODO Auto-generated method stub
		printStringMethod();
	}
	public void setIsContinuePrint(Boolean isContinuePrint) {
		this.isContinuePrint = isContinuePrint;
	}
    }

----------

    package printString;

    public class TestMain {
	public static void main(String[] args) throws InterruptedException {
		// TODO Auto-generated method stub
		PrintString printString=new PrintString();
		printString.start();
		System.out.println("停止线程");
		Thread.sleep(1000);
		printString.setIsContinuePrint(false);
	}
    }

**运行结果：**

![](https://i.imgur.com/4jXHkjW.png)

**问题原因：**
私有堆栈中值和公共堆栈中的值不统一造成，解决问题使用Valatile关键字修饰isContinuePrint使取值时强制从公共堆栈中取值。

###2.3.2 volatile不支持原子性
volatile关键字增加了实例变量在多个线程之间的可见性，但是volatile关键字不支持变量的原子性。

###2.3.3 变量在内存中的工作过程









